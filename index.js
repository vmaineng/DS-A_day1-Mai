//Problem 1
//Big O notation is a method to measure algorithms. 
//It takes into consideration how much time the code will take to run (time) and how much memory it will consume (space). 
//Also, it helps look at the trends of the code instead of each specific details.

//Problem 2
//constant = rank 1; 
//It doesn't matter on the length of the inputs because the time complexity will remain the same.
//ex: const example1 = (num1, num2) => {
//return num1 + num2
//}
//

//logarimetic = rank 2; 
//This time complexity starts increasing in the beginning and slowly decreased at the end because it does not look at each elements
//ex: skip by 2+ in the step && binary search
// for (let i = 0; i < arr.length; i*=2){
//console.log(i);
//}

//linear = rank 3; iterate one item at a time
//ex: for..loops, while loop, forEach, map, find
//array.map(nums)

//quadratic - n x n; rank 4; 
//ex: nested for loops; map inside a for loop
//is exponential and quadratic = same?

//factorial = rank 5; difficult to achieve in real life
//ex: recursion

//Problem 3
//all computers will produce different output
//save time and money, and can't assess the same code with all computers
//scalability of the code ; if we add more data and code, we want it to execute it effectively

//Problem 4
//Not all computers and browsers are built equally; therefore, they will produce a different time output each time.
//every browsers are built different

//Problem 5
//total: 0(1)+ O(n) + O(n) + O(n^2)

//consolidated: 1 + 2n+ n^2 => 1 + n + n^2 => n^2

//n^2 b/c we look at worst case scenario

//Problem 6
//total: 1 + n + n ^ 3

//consolidated: n^3

//Problem 7
//we don't care about details, we care about trend
//which one is the worst behavior

//Problem 8
//space = how much memory it takes
//save money to use less memory in the computer

//problem 9
//boolean = constant ; 1 or 0;
//undefined = constant
//null = constant
//number = constant
//string = linear; strings can be constant;
//array = linear
//object = linear

//problem 10
//array = 1) ordered list,
//object = 1) key collection,

//problem 11
//1) constant
//inserting: constant
//removing:
//searching 1: linear
//searching 2: linear
//accessing:
//retrieving keys:
//retrieving values:

//problem 12
//push: constant
//unshift: linear
//remove 1: constant
//remove 2: linear
//searching 1: linear
//searching 2: quadratic
//retrieving: constant
//method 1: linear
//method 2: linear
//method 3: linear
//method 4: linear
//method 5: linear
//method 6: linear

//problem 13
//problem 1

//problem 2

//problem 3

//problem 4

//problem 5

//problem 6

//problem 7

//problem 8

//problem 9

//problem 10
